# 🤖 AI 활용 프로젝트 포트폴리오

이세령 | Backend / Full-stack Engineer  
GitHub: https://github.com/Hediar  
Blog: https://velog.io/@hediar


---

## 0. AI 활용에 대한 기본 철학

저는 AI를 “결과를 대신 만들어주는 도구”가 아닌, 개발 생산성과 설계 정확도를 높이는 협업 도구로 활용합니다.

### 공통적인 AI 활용 방식

- **요구사항 정리 (Human)**
  - 기획자 / 팀원과 기능 범위·애매한 지점 먼저 합의
- **설계 정리 (Human + Tool)**
  - Text 명세 + diagram 도구(dbdiagram.io, FigJam 등)
- **AI 지시 (Prompt Engineering)**
  - 최대한 명확하고 제약이 많은 요구
  - 기능 단위를 잘게 쪼개서 요청
- **결과 검증 (Human)**
  - 코드 리뷰, 로그 포인트 삽입, 예상 플로우 검증
- **수정 및 고도화**
  - AI 초안 → 직접 리팩토링
- **Git 단위 관리**
  - 기능 단위 커밋으로 언제든 롤백 가능하게 유지

### 사용 도구 선택 기준

- **Codex (OpenAI 계열)**
  - 코드 맥락 이해, 텍스트 기반 요구사항 해석에 강점
- **Claude**
  - Codex와 같은 요구를 했을 때, 다른점을 비교하기 위해 사용

> “명확하게 요구할수록, 결과는 예상에서 벗어나지 않는다” 라고 생각합니다.

---

## 1. AI를 활용한 문제 해결 / 자동화 사례

### 📌 경량 로그 수집 & 모니터링 시스템

#### 문제 상황
- 원격 서버 로그를 주기적으로 수집해야 함
- 기존 방식: cron + scp + OpenSearch

#### 문제점
- 환경별 의존성 이슈
- 전송 방식 혼재
- 중복 로그 유입 가능성

#### AI 활용 방법 (How)

1. **요구사항을 텍스트로 명확히 정의**
   - 로그 양은 많지 않음
   - 운영 환경 안정성이 최우선
   - 배포/파일 이동 시 단일 전송 방식 선호
   - 중복 데이터 유입 방지 필요

2. **AI에게 “설계 초안” 요청**
   - 기존 구조(cron + scp)를 설명
   - 대체 가능한 방식 제안 요청
   - 👉 AI가 SFTP 단일 방식을 제안

3. **AI 제안 검증 & 채택**
   - scp / rsync 대비
   - 포트 관리 명확
   - 인증 구조 단순
   - 운영 환경 일관성 확보

#### 구현 상세

- **수집 구조**
  - cron ingest job (쓰기)
  - API 서버 (읽기) 분리

- **중복 방지**
  - 로그 _id를 hash 기반으로 생성
  - 동일 로그 재수집 방지

- **저장소**
  - OpenSearch

#### 개선 결과

| 항목 | 개선 전 | 개선 후 |
|------|---------|---------|
| 로그 전송 방식 | scp / rsync 혼용 | SFTP 단일 |
| 운영 안정성 | 환경 의존적 | 환경 독립 |
| 중복 데이터 | 수동 관리 | Hash 기반 차단 |

#### 기여도
- 아키텍처 설계: 100%
- AI 활용: 설계 대안 제안 및 검증 보조
- 코드 구현: 본인 100% (AI 초안 참고)

---

## 2. AI로 생성한 초안 vs 최종 산출물

### 📌 불도저(BDZ) 프로젝트 – ERD 설계 자동화

#### 배경
- 팀원/기획자와 기능 정의 문서 먼저 정리
- 애매한 정책은 사전 조율 후 확정
- 이후 AI를 활용해 dbdiagram.io ERD 문서 생성

#### 사전 정리한 요구사항 (Human)

**공통**
- id (PK)
- 생성일, 수정일 (Nullable)

**User**
- 이메일, 비밀번호, 이름, 전화번호
- 역할, 차번호, 프로필 이미지
- 활성화 여부, 이메일 인증 여부

**알림**
- 사용자 ID(FK)
- 알림 종류, 메시지, 상태, 발송 시간

**예약**
- 시작/종료 시간
- 차량 번호
- 예약 상태

**결제**
- 결제 수단, 상태, PG 트랜잭션
- 결제 금액, 실패 사유

#### AI 활용 방법

1. **명확한 프롬프트**
   - 위 요구사항을 기준으로
   - dbdiagram.io 문법 사용
   - 테이블 간 관계 명확히
   - 1:N, 1:1 관계 구분
   - 공통 컬럼 재사용

2. **AI가 생성한 ERD 초안**
   - 전체 테이블 구조 자동 생성
   - FK 관계 자동 연결

#### 문제점 (AI 초안)
- 일부 관계 누락
- 예약/결제 흐름이 실제 비즈니스와 불일치
- Nullable 정책 미흡

#### 최종 수정 (Human)
- 관계 재정의
- 정책 컬럼 추가
- 실제 API 흐름 기준으로 테이블 분리

#### 기여도
- 요구사항 정의: 100%
- ERD 구조 설계: Human 70% + AI 30%
- 최종 검증 및 수정: 100%

---

## 3. AI의 한계를 겪고 해결한 경험

### 📌 Viewtrack 백엔드 NestJS 마이그레이션

#### 문제 상황
- 기존 프로젝트 구조 유지 필요
- JS → TS 마이그레이션
- 타입 관리가 핵심
- OpenSearch + Redis 기반 데이터 조회 기능 필요

#### AI 활용 방식

1. **기존 소스코드를 제공**
   - “전체 재작성 금지”
   - “기존 구조 유지”
   - “기능별 폴더 분리”

2. **AI가 제안한 초기 구조**
   - NestJS 모듈 분리
   - Service / Controller / Module 구조

#### AI 한계
- 실제 런타임 의존성 고려 부족
- Redis / TS Redis 타입 불일치
- OpenSearch 쿼리 일부 환각

#### 해결 과정
- 타입 에러 직접 해결
- OpenSearch 쿼리는 공식 문서 기준으로 재작성
- 핵심 기능만 AI 사용, 나머지는 수동 구현

#### 결과
- 점진적 마이그레이션 성공
- 가장 중요한 장치 데이터 조회 기능 안정화

#### 기여도
- 마이그레이션 전략: 100%
- AI 활용: 구조 초안 & 코드 참고
- 최종 구현 및 안정화: 100%

---

## 4. 실제 사용한 프롬프트 템플릿

### 구조화된 프롬프트 예시

```
다음 조건을 만족하는 NestJS 코드를 작성해주세요.

[목표]
- OpenSearch + Redis 기반 조회 API

[제약]
- 기존 프로젝트 구조 유지
- TypeScript strict mode
- 기능별 폴더 분리

[출력]
- Controller / Service 파일 분리
- 주요 로직에 주석 포함
```

#### 효과
- 불필요한 재작업 감소
- AI 결과물 수정 비용 최소화

---

## 마무리

이 포트폴리오는 **“AI를 얼마나 썼는지”보다
“AI를 개발 프로세스 안에서 어떻게 통제하고 활용했는지”**에 초점을 맞췄습니다.

- AI는 설계 보조
- 최종 책임은 사람
- 검증 가능한 구조와 로그, 커밋이 가장 중요

👉 AI와 협업할 줄 아는 개발자로서의 역량을 보여주고자 했습니다.
